clear; ca; clc;

load pre_nn_20SDF_H_30_short
n_tr = 1;

best_p = nan(1,8);
best_pdt = cell(1,8);
all_p = best_pdt;

pdt_arr = 1:8; % possible predictors
n_pdt_arr = 1:8; % number of predictors to include each time

for zz = 1:length(n_pdt_arr)
    
    %% load predictors
    n_pdt = n_pdt_arr(zz);
    C = nchoosek(pdt_arr,n_pdt);
    
    P_ARR = nan(size(C,1),n_tr);
    E_ARR = P_ARR;
    TR_ARR = cell(length(pdt_arr),1);
    Y_ARR = TR_ARR;
    
    for ii = 1:size(C,1)
        
        disp([num2str(zz) ',' num2str(ii) '/' num2str(size(C,1)) ', [' ,num2str(C(ii,:)) ']']);
        
        pp = C(ii,:); % select predictors
        predictor = PDT(pp,:); [predictor,PS_pdt] = mapminmax(predictor); % normalization
        response = RSP; [response,PS_rsp] = mapminmax(response);         % normalization
        
        %% Solve an Input-Output Fitting problem with a Neural Network
        % Script generated by Neural Fitting app
        % Created 28-Sep-2018 17:13:57
        
        x = predictor;
        t = response;
        
        % Choose a Training Function
        % For a list of all training functions type: help nntrain
        % 'trainlm' is usually fastest.
        % 'trainbr' takes longer but may be better for challenging problems. %%%%%% SUPPORTS REGULARIZATION %%%%%%
        % 'trainscg' uses less memory. Suitable in low memory situations.
        trainFcn = 'trainlm';  % Levenberg-Marquardt backpropagation.
        
        %% repeatedly train the network and find the best
        p_arr = nan(1,n_tr);
        e_arr = p_arr;
        tr_arr = cell(1,n_tr);
        y_arr = tr_arr;
        
        for nn = 1:n_tr
            
            % Create a Fitting Network
            hiddenLayerSize = 10;
            net = fitnet(hiddenLayerSize,trainFcn);
            
            % Setup Division of Data for Training, Validation, Testing
            net.divideParam.trainRatio = 70/100;
            net.divideParam.valRatio = 15/100;
            net.divideParam.testRatio = 15/100;
            
            
            % Train the Network
            [net,tr] = train(net,x,t);
            
            % Test the Network
            y = net(x);
            e = gsubtract(t,y);
            p = perform(net,t,y);
            
            y = mapminmax('reverse',y,PS_rsp); % reverse normalization
            
            p_arr(nn) = p;
            e_arr(nn) = norm(e);
            tr_arr{nn} = tr;
            y_arr{nn} = y;
            
            clear net
            
        end
        
        P_ARR(ii,:) = p_arr;
        E_ARR(ii,:) = e_arr;
        TR_ARR{ii} = tr_arr;
        Y_ARR{ii} = y_arr;
        
    end
    
    [ind_a,ind_b] = find(P_ARR==min(min(P_ARR)));
    all_p{zz} = P_ARR;
    best_p(zz) = P_ARR(ind_a,ind_b);
    best_pdt{zz} = PDT_txt{C(ind_a,:)};
    
end

save('nn_20SDF_H_30_short_test_Npdt');


%%

load nn_20SDF_H_30_short_test_Npdt

plot(best_p,'*-');