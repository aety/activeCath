clear; clc; ca;
load circular_approx_curVar_wSine_3D_rotate_findApex;

%%
readme = 'Varying bending angles and varying rotation angles';

pdt_txt_arr = {
    'x_{avg}',      'y_{avg}',      'd_{avg}',      '\alpha_{avg}',     '\Delta\alpha_{avg}'...
    'x_{avg,odd}',  'y_{avg,odd}',  'd_{avg,odd}',  '\alpha_{avg,odd}', '\Delta\alpha_{avg,odd}'...
    'x_{avg,even}', 'y_{avg,even}', 'd_{avg,even}', '\alpha_{avg,even}','\Delta\alpha_{avg,even}'...
    'x_{avg,o-e}',  'y_{avg,o-e}',  'd_{avg,o-e}',  '\alpha_{avg,o-e}', '\Delta\alpha_{avg,o-e}'...
    ...
    'x_{std}',      'y_{std}',      'd_{std}',      '\alpha_{std}',     '\Delta\alpha_{std}'...
    'x_{std,odd}',  'y_{std,odd}',  'd_{std,odd}',  '\alpha_{std,odd}', '\Delta\alpha_{std,odd}',...
    'x_{std,even}', 'y_{std,even}', 'd_{std,even}', '\alpha_{std,even}','\Delta\alpha_{std,even}',...
    'x_{std,o-e}',  'y_{std,o-e}',  'd_{std,o-e}',  '\alpha_{std,o-e}', '\Delta\alpha_{std,o-e}',...
    ...
    'x_{max}',      'y_{max}',      'd_{max}',      '\alpha_{max}',     '\Delta\alpha_{max}'...
    'x_{max,odd}',  'y_{max,odd}',  'd_{max,odd}',  '\alpha_{max,odd}', '\Delta\alpha_{max,odd}'...
    'x_{max,even}', 'y_{max,even}', 'd_{max,even}', '\alpha_{max,even}','\Delta\alpha_{max,even}'...
    'x_{max,o-e}',  'y_{max,o-e}',  'd_{max,o-e}',  '\alpha_{max,o-e}', '\Delta\alpha_{max,o-e}'...
    ...
    'x_{min}',      'y_{min}',      'd_{min}',      '\alpha_{min}',     '\Delta\alpha_{min}'...
    'x_{min,odd}',  'y_{min,odd}',  'd_{min,odd}',  '\alpha_{min,odd}', '\Delta\alpha_{min,odd}'...
    'x_{min,even}', 'y_{min,even}', 'd_{min,even}', '\alpha_{min,even}','\Delta\alpha_{min,even}'...
    'x_{min,o-e}',  'y_{min,o-e}',  'd_{min,o-e}',  '\alpha_{min,o-e}', '\Delta\alpha_{min,o-e}'...
    };

rsp_txt_arr = {'\theta_{rot}','\theta_{bend}'};

predictor = nan(length(pdt_txt_arr),size(X_ARR,1)*size(X_ARR,2));
response = nan(length(rsp_txt_arr),size(X_ARR,1)*size(X_ARR,2));

for ii = 1:size(X_ARR,1)
    for jj = 1:size(X_ARR,2)
        
        % counter
        nn = ii + (jj-1)*size(X_ARR,1);
        
        % extract peaks in each frame
        x = X_PKS_ARR{ii,jj};   % helix peaks x
        y = Y_PKS_ARR{ii,jj};   % helix peaks y
        d = sqrt(x.^2 + y.^2);  % helix peaks distance from origin
        
        % slope change
        alpha= atan2(diff(y),diff(x));  % arctangent of local slopes (length = N-1)
        dalpha = diff(alpha);           % change of the arctangent of local slopes (length = N-2)
        
        % separate odd and even indices
        x_odd = x(1:2:end);     % helix peaks x odd
        y_odd = y(1:2:end);     % helix peaks y odd
        d_odd = d(1:2:end);     % helix peaks d odd
        alpha_odd = atan2(diff(y_odd),diff(x_odd)); % arctangent of local slopes ODD
        dalpha_odd = diff(alpha_odd);               % change of the arctangent of local slopes ODD
        
        x_even = x(2:2:end);    % helix peaks x even
        y_even = y(2:2:end);    % helix peaks x even
        d_even = d(2:2:end);    % helix peaks d even
        alpha_even = atan2(diff(y_even),diff(x_even));  % arctangent of local slopes EVEN
        dalpha_even = diff(alpha_even);                 % change of the arctangent of local slopes EVEN
        
        
        % list predictors
        predictor(:,nn) = [...
            mean(x),mean(y),mean(d),mean(alpha),mean(dalpha),...
            mean(x_odd),mean(y_odd),mean(d_odd),mean(alpha_odd),mean(dalpha_odd),...
            mean(x_even),mean(y_even),mean(d_even),mean(alpha_even),mean(dalpha_even),...
            mean(x_odd)-mean(x_even),mean(y_odd)-mean(y_even),mean(d_odd)-mean(d_even),mean(alpha_odd)-mean(alpha_even),mean(dalpha_odd)-mean(dalpha_even),...
            ...
            std(x),std(y),std(d),std(alpha),std(dalpha),...
            std(x_odd),std(y_odd),std(d_odd),std(alpha_odd),std(dalpha_odd),...
            std(x_even),std(y_even),std(d_even),std(alpha_even),std(dalpha_even),...
            std(x_odd)-std(x_even),std(y_odd)-std(y_even),std(d_odd)-std(d_even),std(alpha_odd)-std(alpha_even),std(dalpha_odd)-std(dalpha_even),...
            ...
            max(x),max(y),max(d),max(alpha),max(dalpha),...
            max(x_odd),max(y_odd),max(d_odd),max(alpha_odd),max(dalpha_odd),...
            max(x_even),max(y_even),max(d_even),max(alpha_even),max(dalpha_even),...
            max(x_odd)-mean(x_even),max(y_odd)-mean(y_even),max(d_odd)-mean(d_even),max(alpha_odd)-mean(alpha_even),max(dalpha_odd)-mean(dalpha_even),...
            ...
            min(x),min(y),min(d),min(alpha),min(dalpha),...
            min(x_odd),min(y_odd),min(d_odd),min(alpha_odd),min(dalpha_odd),...
            min(x_even),min(y_even),min(d_even),min(alpha_even),min(dalpha_even),...
            min(x_odd)-mean(x_even),min(y_odd)-mean(y_even),min(d_odd)-mean(d_even),min(alpha_odd)-mean(alpha_even),min(dalpha_odd)-mean(dalpha_even)];
        
        % list responses
        response(:,nn) = [rot_arr(ii);
            variable_arr(jj)];
    end
end

% Normalize predictors and responses for neural network
[PDT,PDT_mean,PDT_std] = nn_normalize_MS(predictor);
[RSP,RSP_mean,RSP_std] = nn_normalize_MS(response);

%%
n_col_plt = 4;
hold on;
c_arr = colormap(plasma(size(predictor,1)));
for kk = 1:size(predictor,1)
    subplot(n_col_plt,ceil(size(predictor,1)/n_col_plt),kk);
    plot(PDT(kk,:),'.','color',c_arr(kk,:));
    axis tight;
    title(pdt_txt_arr{kk},'color',c_arr(kk,:));
end

%% save
save nn_fitting_pre predictor response *_txt_arr readme PDT* RSP*;